## **Залишкові параметри**

Ми вже знаємо, що викликати функцію можна **з будь-якою кількістю аргументів** незалежно від того, як її було визначено. Зайві аргументи не викличуть помилку.

```js
function multiply(a, b) {
	console.log(a, b)
}

multiply(1, 2); // 1 2
multiply(1, 2, 3); // 1 2
multiply(1, 2, 3, 4); // 1 2
```

У прикладі вище проблема в тому, що аргументів більше, ніж параметрів. І будуть використані лише перші два аргументи — за кількістю оголошених параметрів.

Ми вже вміємо розв'язувати такі завдання, використовуючи псевдомасив [[arguments]], у який збираються всі передані аргументи.

```js
function multiply() {
	console.log(arguments)
}

multiply(1, 2); // псевдомасив [1, 2]
multiply(1, 2, 3); // псевдомасив [1, 2, 3]
multiply(1, 2, 3, 4); // псевдомасив [1, 2, 3, 4]
```

Починаючи зі стандарту ES6, з'явилася концепція залишкових параметрів (`...rest`). Це спеціальний синтаксис, який дозволяє зібрати групу незалежних елементів у масив.

```js
function multiply(...args) {
  console.log(args);
}

multiply(1, 2); // [1, 2]
multiply(1, 2, 3); // [1, 2, 3]
multiply(1, 2, 3, 4); // [1, 2, 3, 4]
```

Вільні параметри можуть бути позначені через три крапки `...`. Буквально це означає: "збери параметри, що залишилися, і поклади їх у масив". Ім'я параметра може бути довільним. Найчастіше його називають `args` або `rest`.

---
## **Збір частини аргументів**

Операція `(...rest)` також дозволяє зібрати в масив тільки ту частину аргументів, яка необхідна. Для цього потрібно оголосити параметри до «збирання». Можна покласти перші кілька параметрів у змінні, а решту — зібрати в масив.

```js
function multiply(first, second, ...args) {
  console.log(first, second, args);
}

multiply(1, 2); // 1 2
multiply(1, 2, 3); // 1 2 [3] 
multiply(1, 2, 3, 4); // 1 2 [3, 4]
```

Усі аргументи, для яких будуть оголошені параметри, передадуть їм свої значення, інші аргументи міститимуться в масиві.

- У параметр `first` буде поміщено перший аргумент
- У параметр `second` буде поміщено другий аргумент
- У параметр `args` буде поміщено масив з інших аргументів

Операція `rest` збирає решту всіх аргументів, а тому повинна завжди бути останньою в підписі функції, інакше виникне помилка `SyntaxError: Rest parameter must be last formal parameter`.

Це викличе помилку ❌:

```js
function multiply(first, ...args, second) {
}
```

Це також викличе помилку ❌:

```js
function multiply(...args, first, second) {
}
```

---
## **Входження параметрів**

Ти вже знаєш, як отримати масив зі списку аргументів.

Інколи потрібно зробити протилежне — передати масив поелементно у функцію, яка викликається. Наприклад, є вбудована функція `Math.max()`, яка шукає та повертає найбільший з аргументів (чисел), тобто очікує не масив значень, а довільну кількість аргументів.

```js
Math.max(14, -4, 25, 8, 11);
```

Уяви, що є масив температур у вигляді чисел `[14, -4, 25, 8, 11]`.

Як викликати для нього `Math.max`? Адже він очікує отримати список чисел, а не один масив.

```js
const temps = [14, -4, 25, 8, 11];

console.log(temps); // [14, -4, 25, 8, 11]

// ❌ Так не спрацює, тому що передаємо цілий масив
console.log(Math.max(temps)); // NaN
```

Тут доцільно використати оператор розпилення `...spread`.

Він схожий на залишкові параметри — теж використовує `...`, але робить абсолютно протилежне. Коли функціонал `...spread` використовується при виклику функції, він перетворює масив на список аргументів.

```js
const temps = [14, -4, 25, 8, 11];

console.log(...temps); // 14 -4 25 8 11  набір окремих чисел 

// ✅ Передамо колекцію елементів у якості окремих аргументів
console.log(Math.max(...temps)); // 25
```

---
## **Створення масиву**

Операція `...spread` дозволяє створити копію масиву або «склеїти» довільну кількість масивів в один новий. Досі для цього використовувалися методи [[Метод .slice()]] і [[Метод .concat()]], але операція розпилення дозволяє зробити те саме в коротшій формі.

Розгляньмо приклад нижче, де створена копія масиву.

```js
const temps = [14, -4, 25, 8, 11];

// Це точна, але незалежна копія масиву temps
const copyOfTemps = [...temps];
console.log(copyOfTemps); // [14, -4, 25, 8, 11]
```

Уяви, що `temps` — це ящик яблук, і ми хочемо створити його точну копію. Беремо порожній ящик і пересипаємо в нього яблука з вихідного ящика `temps` — розподіляємо його в іншу колекцію. За такої умови ящик `temps` не зміниться, у ньому все ще будуть яблука, а в новому ящику — їх точні копії.

У наступному прикладі ми зсипаємо яблука з двох ящиків в один новий.

Оригінальні ящики (масиви) не зміняться, а в новому будуть копії усіх їх яблук (елементів). Порядок розподілу важливий — він впливає на порядок елементів у новій колекції.

```js
const lastWeekTemps = [14, 25, 11];
const currentWeekTemps = [23, 17, 18];
const allTemps = [...lastWeekTemps, ...currentWeekTemps];
console.log(allTemps); // [14, 25, 11, 23, 17, 18]
```

---
## **Створення об'єкта**

Операція `spread` дозволяє розпилити властивості довільної кількості об'єктів в один новий.

```js
const first = { propA: 5, propB: 10 };
const second = { propC: 15 };
const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }
```

Порядок розподілу має значення. Імена властивостей об'єкта — унікальні, тому властивості об'єкта, що розпиляються, можуть перезаписати значення вже існуючої властивості, якщо їх імена збігаються.

```js
const first = { propA: 5, propB: 10, propC: 50 };
const second = { propC: 15, propD: 20 };

const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15, propD: 20 }

const fourth = { ...second, ...first };
console.log(fourth); // { propA: 5, propB: 10, propC: 50, propD: 20 }
```

Якби яблука в ящику мали наліпки з позначками, то в одному ящику не могло б бути двох яблук з однаковими позначками. Тому, пересипаючи другий ящик, усі яблука, позначки яких будуть збігатися з тими, що вже знаходяться в новому ящику, замінять існуючі.

Під час розпилення можна додавати властивості в довільне місце. Головне пам'ятати про унікальність імені властивості і про те, що її значення може бути перезаписане.

```js
const first = { propA: 5, propB: 10, propC: 50 };
const second = { propC: 15 };

const third = { propB: 20, ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }

const fourth = { ...first, ...second, propB: 20 };
console.log(fourth); // { propA: 5, propB: 20, propC: 15 }

const fifth = { ...first, propB: 20, ...second };
console.log(fifth); // { propA: 5, propB: 20, propC: 15 }
```