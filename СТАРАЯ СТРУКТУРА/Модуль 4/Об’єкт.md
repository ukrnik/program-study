## Документация по Объекту
### Создание объекта

Объекты создаются чтобы сделать коллекцию из ключей и значений для того чтобы описать в них значения, названия

```js
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  public: true,
  rating: 8.38,
};
```

---
### Вложенные  свойства

Значенням властивості може бути інший об'єкт.
Це використовується для зберігання вкладених і згрупованих даних.

```js
const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};
```

Наприклад, статистика користувача соціальної мережі `stats` складається з кількості підписників, переглядів і лайків, і зберігати ці дані найзручніше у вигляді об'єкта. Те саме з місцем розташування `location`, окремо країна і місто.

У майбутньому це можна буде використовувати для пошуку користувачів за країною, містом, мінімальною або максимальною кількістю підписників тощо.

---
### **Доступ до вкладених властивостей**

Для доступу до вкладених властивостей використовується ланцюжок звернень «через крапку».

**Значення властивості — це вкладений об’єкт.**

Якщо необхідно отримати значення країни користувача, записуємо `user.location.country`, де:

- `user.location` — це звернення (шлях) до об'єкта у властивості `location`,
- `user.location.country` — звернення до властивості `country` в цьому об'єкті.

Тобто «крапка» вказує наступну вкладеність.

```js
const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  hobbies: ["swimming", "music", "sci-fi"],
};

const location = user.location;
console.log(location); // {country: "Jamaica", city: "Ocho Rios"}

const country = user.location.country;
console.log(country); // "Jamaica"
```

**Значення властивості — це масив.**

Якщо значення властивості — це масив, то в нашому прикладі вище звернення до цього **масиву** буде: ****`user.hobbies`

```js
const hobbies = user.hobbies;
console.log(hobbies); // ["swimming", "music", "sci-fi"]
```

Отримати доступ до **елементів масиву** можна через квадратні дужки та індекс: `user.hobbies[0];`

```js
const firstHobby = user.hobbies[0];
console.log(firstHobby); // "swimming"
```

Також можна використовувати властивості й **методи масиву**, наприклад отримати значення його довжини з властивості length: `user.hobbies.length;`

```js
const numberOfHobbies = user.hobbies.length;
console.log(numberOfHobbies); // 3
```

---
### **Доступ до властивостей через крапку**

Перший спосіб отримати доступ до властивості об'єкта — це синтаксис `objectName.key`.

- На місце звернення буде повернуте значення властивості з таким ключем.
- Якщо в об'єкті відсутня властивість з таким ключем, на місце звернення повернеться `undefined`.

Здебільшого синтаксис «через крапку» використовується тоді, коли ми заздалегідь знаємо ім'я (ключ) властивості, до якої хочемо отримати доступ.

```js
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const bookTitle = book.title;
console.log(bookTitle); // "The Last Kingdom"

const bookGenres = book.genres;
console.log(bookGenres); // ["historical prose", "adventure"]

const bookPrice = book.price;
console.log(bookPrice); // undefined
```

---
### **Доступ до властивостей через квадратні дужки**

Другий спосіб отримати доступ до властивості об'єкта — це синтаксис `objectName[”key”]`.

Схоже на звернення до елемента масиву з відмінністю. Відмінність полягає в тому, що в квадратних дужках зазначається не індекс елемента, а рядок з ключем (ім’ям властивості).

Синтаксис «квадратних дужок» використовується значно рідше. Як правило, у випадках, коли ім'я властивості заздалегідь не відоме або воно зберігається у змінній, наприклад, як значення параметра функції.

- На місце звернення буде повернуто значення властивості з таким ім'ям.
- Якщо в об'єкті відсутня властивість з таким ім'ям, на місце звернення повернеться `undefined`.

```js
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

console.log(book.title); // "The Last Kingdom" 
console.log(book["title"]); // "The Last Kingdom" 

console.log(book.genres); // ["historical prose", "adventure"]
console.log(book["genres"]); // ["historical prose", "adventure"]

const propKey = "author";
console.log(book.propKey); // undefined
console.log(book[propKey]); // "Bernard Cornwell"
```

У прикладі вище:

- `console.log(book.propKey);` — це `undefined`, оскільки в об’єкті `book` немає властивості з ключем `propKey`.
- `console.log(book[propKey]);` — це `"Bernard Cornwell"`, оскільки значенням змінної `propKey` є рядок `“author”`, і в об’єкті `book` є властивість з ключем `author`, то цей запис поверне значення властивості author).

---
### **Зміна значення властивостей**

Після того як об'єкт створений, значення його властивостей можна змінити.

Для цього необхідно звернутися до них за ключем, наприклад, «через крапку», і присвоїти нове значення.

```js
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

book.rating = 9;
book.isPublic = false;
book.genres.push("drama");

console.log(book.rating); // 9
console.log(book.isPublic); // false
console.log(book.genres); // ["historical prose", "adventure", "drama"]
```

---
### **Додавання властивостей**

Операція додавання нової властивості після створення об'єкта нічим не відрізняється від зміни значення вже існуючої властивості.

Якщо під час запису значення за ключем така властивість відсутня в об'єкті, вона буде створена.

```js
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

book.pageCount = 836;
book.originalLanguage = "en";
book.translations = ["ua", "ru"];
book.price = {
  hardcover: 39,
  softcover: 29,
};

console.log(book.pageCount); // 836
console.log(book.originalLanguage); // "en"
console.log(book.translations); // ["ua", "ru"]
```

---
### **Короткі властивості**

Іноді під час створення об'єкта значення властивості необхідно взяти зі змінної або параметра функції з таким самим ім'ям, як і сама властивість.

Синтаксис у наступному прикладі занадто громіздкий, адже доводиться дублювати ім'я властивості та ім'я змінної, в якій зберігається необхідне значення: `name: name,` і `age: age,`.

```js
const name = "Henry Sibola";
const age = 25;

const user = {
  name: name,
  age: age,
};

console.log(user.name); // "Henry Sibola"
console.log(user.age); // 25
```

Синтаксис **коротких властивостей** (shorthand properties) вирішує цю проблему, дозволяючи використовувати ім'я змінної як ім'я властивості, а її значення як значення властивості.

```js
const name = "Henry Sibola";
const age = 25;

const user = {
  name,
  age,
};

console.log(user.name); // "Henry Sibola"
console.log(user.age); // 25

```

Замість `name: name,` використали `name`.

А замість `age: age,` — `age`.

Тобто під час оголошення об'єкта достатньо вказати тільки ім'я властивості, а значення буде взято зі змінної з аналогічним ім'ям.

---
### **Обчислювальні властивості**

Бувають ситуації, коли під час оголошення об'єкта необхідно додати властивість з ім'ям, яке ми заздалегідь не знаємо, тому що воно зберігається як значення змінної або як результат виконання функції.

Раніше для цього необхідно було спочатку створити об'єкт, а потім додавати властивості через квадратні дужки, що не зовсім зручно.

```js
const propName = "name";
const user = {
  age: 25,
};

user[propName] = "Henry Sibola";
console.log(user.name); // "Henry Sibola"

```

Синтаксис **обчислювальних властивостей** (computed properties) допомагає уникнути зайвого коду і в деяких випадках спростити його.

Значенням обчислювальної властивості може бути будь-який валідний вираз.

```js
const propName = "name";
const user = {
  age: 25,
  // ключ цієї властивості буде взято зі значення змінної propName
  [propName]: "Henry Sibola",
};

console.log(user.name); // "Henry Sibola"

```

---

### Список методов которые работают с объектами:

| [[Метод Object.keys()]]    | - Возвращает масив из ключей                       |
| -------------------------- | -------------------------------------------------- |
| [[Метод Object.entries()]] | - Возвращает масив в котором масивы `[key, value]` |
| [[Метод Object.values()]]  | - Возвращает масив значений ключей                 |

---

## Масив Объектов

Об'єкти дозволяють згрупувати описові характеристики сутності, наприклад, користувача, книги, автомобіля, шоколадного батончика тощо.

Для опису групи сутностей використовується **масив об'єктів**.

Уяви, що треба описати бібліотеку. Кожна книга — це окремий об’єкт, що містить інформацію про назву, автора, кількість сторінок, рейтинг тощо. Якщо книга — це один об’єкт, то біблотека — це колекція книг, тобто масив об’єктів.

```js
const books = [
  {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    rating: 8.38,
  },
  {
    title: "Beside Still Waters",
    author: "Robert Sheckley",
    rating: 8.51,
  },
  {
    title: "The Dream of a Ridiculous Man",
    author: "Fyodor Dostoevsky",
    rating: 7.75,
  }
];
```

У стандартний набір повсякденних завдань розробника входить маніпуляція масивом однотипних об'єктів. Це означає, що всі об'єкти в масиві гарантовано матимуть однаковий набір властивостей, але з різними значеннями.

Для перебору такого масиву використовується стандартний цикл `for...of`. Значення властивостей кожного об'єкта можна отримати, використовуючи синтаксис «через крапку» (див. тему **Об’єкти**. _Доступ до властивостей через крапку_), оскільки в кожному об'єкті набір властивостей та їх імена будуть однакові, відрізнятимуться тільки значення.


```js
for (const book of books) {
  console.log(book); // Об'єкт книги
  console.log(book.title); // Назва
  console.log(book.author); // Автор
  console.log(book.rating); // Рейтинг
}
```

---
### Пошук об'єкта за значенням властивості

Стандартне завдання під час роботи з масивом об'єктів — це пошук об'єкта за значенням властивості. Наприклад, потрібно знайти книгу за її автором. Для цього необхідно:

- перебрати масив у циклі;
- додати умову, виконання якої означатиме успішний результат пошуку.

```js
const books = [
  { title: "The Last Kingdom", author: "Bernard Cornwell" },
  { title: "Beside Still Waters", author: "Robert Sheckley" },
  { title: "The Dream of a Ridiculous Man", author: "Fyodor Dostoevsky" }
];

const authorToSearchFor = "Robert Sheckley";

for (const book of books) {
	if(book.author === authorToSearchFor) {
		console.log(book);
		console.log(book.title)
		console.log(book.rating)
	}
}
```

У прикладі вище `цикл for` перебирає об'єкти в масиві, доки не знайде той, у якого порівняння значення властивості `author` і `authorToSearchFor` поверне `true`. Щойно об’єкт з необхідним автором знайдено, виконається тіло `if`, де ми вже можемо працювати зі знайденим об'єктом.

---
### **Колекція значень властивості**

Типова задача під час роботи з колекцією об'єктів — це отримання масиву всіх значень певної властивості об'єктів. Наприклад, взяти з масиву об'єктів, які описують книги, усі назви або рейтинг.

Для цього необхідно:

1. Створити новий порожній масив для зберігання значень властивостей.
2. Перебрати масив об'єктів у циклі.
3. На кожній ітерації додати в новий масив значення необхідної властивості.

Наприклад, отримаємо список назв усіх книг у колекції `books`.

```js
const books = [
  { title: "The Last Kingdom", author: "Bernard Cornwell", rating: 8.2 },
  { title: "Beside Still Waters", author: "Robert Sheckley", rating: 9 },
  { title: "The Dream of a Ridiculous Man", author: "Fyodor Dostoevsky", rating: 6.8 }
];

const titles = [];

for (const book of books) {
	titles.push(book.title)
}

console.log(titles); // ["The Last Kingdom", "Beside Still Waters", "The Dream of a Ridiculous Man"]

```

У результаті вийде масив значень певної властивості з усіх об'єктів.

Дізнаємося середній рейтинг усієї нашої колекції. Для цього треба скласти всі рейтинги й розділити отримане значення на кількість книг.

```js
const books = [
  { title: "The Last Kingdom", author: "Bernard Cornwell", rating: 8.2 },
  { title: "Beside Still Waters", author: "Robert Sheckley", rating: 9 },
  { title: "The Dream of a Ridiculous Man", author: "Fyodor Dostoevsky", rating: 6.8 }
];

let totalRating = 0;

for (const book of books) {
  totalRating += book.rating;
}

const averageRating = totalRating / books.length;
console.log(averageRating); // 8

```

---
## Методы Объекта

Досі ми розглядали об'єкти тільки як сховища взаємопов'язаних даних (наприклад, дані про книгу). **Об'єкти-сховища** зазвичай містяться в масиві таких самих об'єктів. Цей масив є колекцією однотипних елементів.

А що, якщо нам потрібно створити функції для виконання операцій над масивом даних? Наприклад, додавання або видалення книги. І ці функції мають виконуватися багато разів.

```
// ❌ Слабкопов'язані, незалежні сутності
const books = ["The Last Kingdom", "Dream Guardian"];
function getBooks() {}
function addBook() {}
```

Один із варіантів — оголосити змінну `books` і дві функції `getBooks()` і `addBook(bookName)` 

Цей спосіб має недоліки. Адже ми маємо три незалежні сутності без явного синтаксичного зв’язку і зі слабким логічним. Є краще рішення.

Об'єкти можуть зберігати не тільки дані, але й функції для роботи з цими даними. Якщо значення властивості — це функція, така властивість називається **методом об'єкта**.

```
const obj = {
	method(value) {
		console.log(`I'm a method with ${value}!`);
	}
};

obj.method(5); // "I'm a method with 5!"
obj.method(10); // "I'm a method with 10!"
```

- Метод — це звичайна функція, оголошена як властивість об'єкта (див. приклад вище), а не як окрема змінна (див. перший приклад у розділі).
- Для звернення до методу об'єкта використовується стандартний синтаксис із крапкою.

Об'єкти, які пов'язують дані та методи для роботи з цими даними, можна назвати «моделями».

Створимо об’єкт `bookShelf` для колекції книг `books` і методів взаємодії з колекцією `getBooks` і `addBook`.

```
// ✅ Логічно й синтаксично згруповані сутності
const bookShelf = {
  books: ["The Last Kingdom", "Dream Guardian"],
  // Це метод об'єкта
  getBooks() {
    return "Returning all books";
  },
  // Це метод об'єкта
  addBook(bookName) {
		return `Adding book ${bookName}`;
  },
};

// Виклики методів
bookShelf.getBooks(); // поверне "Returning all books"
bookShelf.addBook("New book 1"); // поверне "Adding book New book 1"
bookShelf.addBook("New book 2"); // поверне "Adding book New book 2"
```

---
### **Доступ до властивостей об'єкта**

Методи використовуються для роботи з властивостями об'єкта та їх змінних.

Для **доступу до об'єкта** в методі використовується не ім'я змінної цього об’єкта, наприклад `bookShelf`, а ключове слово `this`.

Ключове слово `this` — це контекст виконання функції.

```
const bookShelf = {
  books: ["The Last Kingdom", "The Mist"],
  getBooks() {
    console.log(this);
  },
};

bookShelf.getBooks(); // {books: ["The Last Kingdom", "The Mist"], getBooks: f}
```

Значенням `this` буде посилання на об'єкт перед «крапкою», тобто об'єкт, який викликав цей метод, у нашому випадку — це посилання на об'єкт `bookShelf`.

![[Pasted image 20240908041321.png]]

Для **доступу до властивостей об'єкта** в методах звертаємось до нього через `this` і далі, стандартно, «через крапку» до властивостей.

```
const bookShelf = {
  books: ["The Last Kingdom", "The Mist"],
  getBooks() {
    return this.books;
  }
};

console.log(bookShelf.getBooks()); // ["The Last Kingdom", "The Mist"]
```

![[Элемент this.png]]

Логічно замислитися, чому б не використовувати ім'я об'єкта у зверненні до властивостей?

Адже ми явно не збираємося його змінювати.

Справа в тому, що ім'я об'єкта — річ ненадійна. Методи одного об'єкта можна копіювати в інший (з іншим ім'ям), а в майбутньому дізнаємось, що часто при створенні об'єкта ми наперед зовсім не знаємо імені. Використання `this` гарантує, що метод працює саме з тим об'єктом, який його викликав.

---
### **Зміна за посиланням**

У властивості `books` об'єкта `bookShelf` зберігається масив.

Отже, ми можемо змінювати масив за посиланням, звертаючись до властивості `bookShelf.books`, тому що це посилання на масив.

```
const bookShelf = {
  books: ["The Last Kingdom"],
};

bookShelf.books.push("The Mist");
console.log(bookShelf.books); // ["The Last Kingdom", "The Mist"]
```

У прикладі нижче в ключовому слові `this` зберігається посилання на об'єкт, що викликав відповідний метод.

Під час звернення до `this.books` усередині методу, ми посилаємось на масив, що зберігається у властивості `books`. Це означає, що його можна змінювати за посиланням, наприклад, використавши метод масиву `push()` для додавання нового елемента.

```
const bookShelf = {
  books: ["The Last Kingdom"],
  getBooks() {
    return this.books;
  },
  addBook(bookName) {
    this.books.push(bookName);
  }
};

console.log(bookShelf.getBooks()); // ["The Last Kingdom"]
bookShelf.addBook("The Mist");
bookShelf.addBook("Dream Guardian");
console.log(bookShelf.getBooks()); // ["The Last Kingdom", "The Mist", "Dream Guardian"]
```

При цьому з методу `addBook` не потрібно нічого повертати, якщо цього не вимагає завдання. Під час його виклику ми просто міняємо значення масиву за посиланням — і елементи масиву у властивості `books` змінюються.

---
### **Масив об’єктів**

Ти вже знаєш, що об'єкт дає змогу згрупувати характеристики сутності, наприклад, книги.

Тому найчастіше будемо працювати з масивом об'єктів. Для цього зберігатимемо у властивості `books` не рядки, а об'єкти з назвою книги та рейтингом, а в майбутньому, можливо, й іншими характеристиками.

```
const bookShelf = {
  books: [
		{ title: "The Last Kingdom", rating: 8 }, 
		{ title: "The Mist", rating: 6 }
	],
	getBooks() {
		return this.books;
	}
};

```
